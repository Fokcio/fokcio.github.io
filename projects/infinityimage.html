<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<title>Infinity Paint ‚Äî Niesko≈Ñczone rysowanie</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #0d0d0f;
    font-family: sans-serif;
    color: white;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 8px;
    font-size: 14px;
  }
  #ui button {
    background: #3a3aff;
    color: white;
    border: none;
    padding: 6px 10px;
    border-radius: 5px;
    cursor: pointer;
    margin: 5px 2px;
  }
  #ui button:hover { background: #5555ff; }
  .label { color: #a0a0a0; font-size: 12px; }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui">
  <div><b>Infinity Paint</b></div>
  <div class="label">LMB ‚Äî draw / erase</div>
  <div class="label">Scroll ‚Äî zoom</div>
  <div class="label">RMB ‚Äî move</div>
  <button id="draw">‚úèÔ∏è Draw</button>
  <button id="erase">üßΩ Eraser</button>
  <button id="clear">üóëÔ∏èClear</button>
  <button id="save">üíæ Download .PNG</button>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// --- Resize ---
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// --- Kamera ---
let camX = 0, camY = 0, camScale = 1;
let mode = "draw"; // draw / erase

// --- Rysowanie ---
let lines = []; // {x1,y1,x2,y2, erase:boolean}
let drawing = false;
let lastX = 0, lastY = 0;

// --- Przesuwanie kamery ---
let panning = false;
let panStartX = 0, panStartY = 0;
let camStartX = 0, camStartY = 0;

function screenToWorld(x, y) {
  return {
    x: (x - canvas.width/2)/camScale + camX,
    y: (y - canvas.height/2)/camScale + camY
  };
}

canvas.oncontextmenu = e => e.preventDefault();

canvas.addEventListener("mousedown", e=>{
  if(e.button===0){
    drawing = true;
    const p = screenToWorld(e.clientX, e.clientY);
    lastX = p.x;
    lastY = p.y;
  }
  if(e.button===2){
    panning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    camStartX = camX;
    camStartY = camY;
  }
});

canvas.addEventListener("mouseup", e=>{
  if(e.button===0) drawing = false;
  if(e.button===2) panning = false;
});

canvas.addEventListener("mousemove", e=>{
  if(drawing){
    const p = screenToWorld(e.clientX, e.clientY);
    lines.push({x1:lastX,y1:lastY,x2:p.x,y2:p.y, erase:(mode==="erase")});
    lastX = p.x; lastY = p.y;
  }
  if(panning){
    const dx = (panStartX - e.clientX)/camScale;
    const dy = (panStartY - e.clientY)/camScale;
    camX = camStartX + dx;
    camY = camStartY + dy;
  }
});

canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const scaleFactor = Math.exp(-e.deltaY * 0.001);
  const before = screenToWorld(e.clientX, e.clientY);
  camScale *= scaleFactor;
  const after = screenToWorld(e.clientX, e.clientY);
  camX += (before.x - after.x);
  camY += (before.y - after.y);
},{passive:false});

// --- Narzƒôdzia ---
document.getElementById("clear").onclick = ()=>{ lines=[]; };
document.getElementById("draw").onclick = ()=> mode="draw";
document.getElementById("erase").onclick = ()=> mode="erase";

// --- Zapis PNG ---
document.getElementById("save").onclick = ()=>{
  const url = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = "infinity_paint.png";
  a.click();
};

// --- Nagrywanie i odtwarzanie trasy ---
let isRecording = false;
let path = []; // {x,y,scale}
let animIndex = 0;
let animPlaying = false;

const recordBtn = document.createElement("button");
recordBtn.textContent = "üé• Record Animation";
recordBtn.onclick = () => {
  if (!isRecording) {
    path = []; // usu≈Ñ starƒÖ trasƒô
    isRecording = true;
    animPlaying = false;
    recordBtn.textContent = "‚èπÔ∏è Stop";
  } else {
    isRecording = false;
    recordBtn.textContent = "üé• Record Animation";
    console.log("Saved Path:", path);
  }
};
document.getElementById("ui").appendChild(recordBtn);

const playBtn = document.createElement("button");
playBtn.textContent = "‚ñ∂Ô∏è Play animation";
playBtn.onclick = () => {
  if (path.length < 2) return alert("First Record Something!");
  animPlaying = true;
  isRecording = false;
  animIndex = 0;
};
document.getElementById("ui").appendChild(playBtn);

// --- Eksport animacji do WebM ---
const exportBtn = document.createElement("button");
exportBtn.textContent = "üìπ Export MP4";
exportBtn.onclick = () => {
  if (path.length < 2) return alert("Record path first!");
  const stream = canvas.captureStream(60);
  const recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
  const chunks = [];
  recorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };
  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'infinity_animation.webm';
    a.click();
    URL.revokeObjectURL(url);
  };
  recorder.start();

  // Odtw√≥rz trasƒô w pe≈Çnej prƒôdko≈õci dla nagrania
  let tempIndex = 0;
  animPlaying = true;
  function recordStep() {
    if(tempIndex < path.length - 1){
      camX = path[tempIndex].x;
      camY = path[tempIndex].y;
      camScale = path[tempIndex].scale;
      tempIndex++;
      requestAnimationFrame(recordStep);
    } else {
      animPlaying = false;
      recorder.stop();
    }
  }
  recordStep();
};
document.getElementById("ui").appendChild(exportBtn);

// --- Render ---
let lastAnimTime = 0;
const animFPS = 60;

function draw(timestamp){
  requestAnimationFrame(draw);

  // Zapis kamery je≈õli nagrywamy
  if(isRecording){
    path.push({x:camX, y:camY, scale:camScale});
  }

  // Animacja podglƒÖdu ‚Äî p≈Çynna, kontrolowane FPS
  if(animPlaying && path.length>1){
    if(!lastAnimTime) lastAnimTime = timestamp;
    const dt = timestamp - lastAnimTime;
    const frameTime = 1000/animFPS;

    if(dt >= frameTime){
      lastAnimTime = timestamp;
      animIndex = Math.min(animIndex+1, path.length-1);
      camX = path[animIndex].x;
      camY = path[animIndex].y;
      camScale = path[animIndex].scale;
      if(animIndex === path.length-1) animPlaying = false;
    }
  }

  // Czyszczenie
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Kamera
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.scale(camScale, camScale);
  ctx.translate(-camX,-camY);

  // --- Rysowanie linii ---
for(let l of lines){
  ctx.beginPath();
  ctx.lineWidth = Math.max(2/camScale, 0.0001);
  ctx.strokeStyle = l.erase ? "#0d0d0f" : "#ffffff";
  ctx.moveTo(l.x1,l.y1);
  ctx.lineTo(l.x2,l.y2);
  ctx.stroke();
}

// --- Znak wodny ---
ctx.save();
ctx.setTransform(1,0,0,1,0,0); // w ekranowych koordynatach
ctx.font = "20px sans-serif";
ctx.fillStyle = "rgba(255,255,255,0.3)";
ctx.textAlign = "right";
ctx.textBaseline = "bottom";
ctx.fillText("fokcio.github.io", canvas.width - 10, canvas.height - 10);
ctx.restore();
}

requestAnimationFrame(draw);
</script>

</body>
</html>
